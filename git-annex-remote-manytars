#!/usr/bin/env python

import inspect
import os
import tarfile
import sys
from datetime import datetime
from pathlib import Path
from subprocess import CompletedProcess, DEVNULL, Popen, run, STDOUT, PIPE
from shlex import split
from shutil import copy2
from time import sleep
from typing import List

from annexremote import Master
from annexremote import SpecialRemote
from annexremote import RemoteError, ProtocolError


LOGFOLDER = Path("~/projs/git-annex-remote-manytars/testrepo/logs").expanduser()
LOGFOLDER.mkdir(exist_ok=True)


class MountingError(RemoteError):
    pass


def log_stuff(log_path: Path, lines: List[str]):
    with open(LOGFOLDER / log_path, "a") as stdout_file:
        stdout_file.write(f"{datetime.now()}\n")
        stdout_file.write(f"{inspect.stack()[2].function}->")
        stdout_file.write(f"{inspect.stack()[1].function}\n")
        stdout_file.write("\n".join(lines))


def _mkdir(directory: Path):
    try:
        directory.mkdir(parents=True, exist_ok=True)
    except OSError as e:
        raise RemoteError(f"Failed to write to {str(directory)!r}")


def ratarmount(
    mount_source: str,
    mount_point: str,
    recreate_index: bool = False,
) -> CompletedProcess:
    args = f"ratarmount {mount_source} {mount_point}"
    # log_file = str(hash(args))
    args = split(args)
    if recreate_index:
        args.append("--recreate-index")
    proc = run(args, capture_output=True, text=True)
    log_stuff(mount_point.stem, [proc.stdout, proc.stderr])
    # proc = Popen(args, stdin=DEVNULL, stdout=stdout_file, stderr=STDOUT, text=True)
    return proc


def mount_all_and_wait(tar_files: List[Path]):
    processes = [
        ratarmount(str(tar_file), str(tar_file.with_suffix("")))
        for tar_file in tar_files
    ]
    if any(p.retcode != 0 for p in processes):
        raise RemoteError("Could not ratarmount one of the .tar files.")
    # while any(p.poll() is None for p in processes):
    #     sleep(0.1)


def filtermounted(tars: List[Path]) -> List[Path]:
    return [tar_path for tar_path in tars if not tar_path.with_suffix("").is_dir()]


def umount(mount_point: Path):
    args = split(f"umount {mount_point}")
    proc = run(args, capture_output=True, text=True)
    log_stuff(mount_point.name, [proc.stdout, proc.stderr])
    if proc.returncode != 0:
        raise MountingError(f"Could not unmount {mount_point}")


def delete_from_tar(tar_path: str, file_to_remove: str):
    args = split(f"tar -v --delete --file={tar_path} {file_to_remove}")
    proc = run(args, capture_output=True, text=True)
    log_stuff(tar_path.stem, [proc.stdout, proc.stderr])
    if proc.returncode != 0:
        raise RemoteError(f"Could not delete {file_to_remove.name!r} from {tar_path.name!r}.")


class ManyTars(SpecialRemote):

    def initremote(self):
        self.address_length = 1
        self.directory = self.annex.getconfig('directory')
        self.directory = "~/projs/git-annex-remote-manytars/manga"
        if not self.directory:
            raise RemoteError("You need to set directory=")
        self.directory = Path(self.directory).expanduser()
        _mkdir(self.directory)

    def prepare(self):
        self.address_length = 2
        self.directory = Path(self.annex.getconfig('directory'))
        self.directory = Path("~/projs/git-annex-remote-manytars/manga").expanduser()
        self.info = {'directory': self.directory}
        if not self.directory.is_dir():
            raise RemoteError(f"{str(self.directory)!r} not found.")
        # available_tars = self.directory.glob(r"*.tar")
        # unmounted_tars = filtermounted(available_tars)
        # mount_all_and_wait(unmounted_tars)  # O(1) because all indices are already updated 

    def transfer_store(self, key: str, filename: str):
        """

        e.g.:
        filename=".git/annex/objects/qW/pV/SHA256E-s148273064--5880ac1cd05eee90db251c027771b4c9f0a55b7c8b2813c95eff59eef465ebd3.wav/SHA256E-s148273064--5880ac1cd05eee90db251c027771b4c9f0a55b7c8b2813c95eff59eef465ebd3.wav"
        """
        if self.checkpresent(key):
            return
        mount_point = self._get_mount_point(key)
        tar_path = self._get_tar_path(key)
        with tarfile.open(name=tar_path, mode="a:") as tareco:
            tareco.add(filename, arcname=key)
        if mount_point.is_dir():
            umount(mount_point)
            ratarmount(tar_path, mount_point, recreate_index=True)  # O(n)
        else:
            ratarmount(tar_path, mount_point)  # O(n)
        if not self.checkpresent(key):
            raise RemoteError("Unknown error while storing the key.")

    def transfer_retrieve(self, key: str, filename: str):
        if not self.checkpresent(key):
            raise RemoteError("Key not present in this remote.")
        mount_point = self._get_mount_point(key)
        tar_path = self._get_tar_path(key)
        if not mount_point.is_dir():
            ratarmount(tar_path, mount_point)
        copy2(str(mount_point / key), filename)

    def checkpresent(self, key: str):
        mount_point = self._get_mount_point(key)
        tar_path = self._get_tar_path(key)
        if tar_path.is_file():
            if not mount_point.is_dir():
                ratarmount(tar_path, mount_point)
            file_path = mount_point / key
            if file_path.is_file():
                # umount(mount_point)
                return True
        return False

    def remove(self, key: str):
        # remove the key from the remote
        # raise RemoteError if it couldn't be removed
        # note that removing a not existing key isn't considered an error
        if not self.checkpresent(key):
            return 
        
        raise RemoteError("Could not remove.")

    def _get_address(self, key: str) -> str:
        """
        key="SHA256E-s148273064--5880ac1cd05eee90db251c027771b4c9f0a55b7c8b2813c95eff59eef465ebd3.wav"
        """
        parts = key.split("-")
        address = parts[-1][:self.address_length]
        return address

    def _get_mount_point(self, key: str) -> Path:
        return self.directory / self._get_address(key)

    def _get_tar_path(self, key: str) -> Path:
        tar_path = self._get_mount_point(key)
        return tar_path.with_suffix(".tar")

def main():
    output = sys.stdout
    sys.stdout = sys.stderr

    master = Master(output)
    remote = ManyTars(master)
    master.LinkRemote(remote)
    master.Listen()

if __name__ == "__main__":
    main()